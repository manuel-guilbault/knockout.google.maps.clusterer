/*
*   knockout.google.maps.clusterer 0.1.0 (2014-01-15)
*   Created by Manuel Guilbault (https://github.com/manuel-guilbault)
*
*   Source: https://github.com/manuel-guilbault/knockout.google.maps.clusterer
*   MIT License: http://www.opensource.org/licenses/MIT
*/!function(a){"function"==typeof require&&"object"==typeof exports&&"object"==typeof module?a(require("knockout"),exports):"function"==typeof define&&define.amd?define(["knockout","exports"],a):a(ko,ko.validation={})}(function(a){if(void 0===typeof a.google.maps)throw"knockout.google.maps is required, please ensure it is loaded before loading this plugin";!function(){function b(b,c){var d=a.utils.domData.get(b,"clusterer");d&&d.removeMarker(b),a.utils.domData.set(b,"clusterer",c),c&&c.addMarker(b)}function c(a){b(a)}var d="$clusterer";a.bindingHandlers.clusterer={init:function(b,c,e,f,g){if(void 0===g.$map)throw"clusterer binding must be used only inside the scope of a map binding.";var h=a.utils.unwrapObservable(c()),i=a.google.maps.binder.getCreateOptions(g,h,a.bindingHandlers.clusterer.binders),j=new MarkerClusterer(g.$map,[],i),k=new a.google.maps.Subscriptions;a.google.maps.binder.bind(g,h,j,k,a.bindingHandlers.clusterer.binders);var l=a.utils.unwrapObservable(h.name)||d,m={};m[l]=j;var n=g.extend(m);return a.applyBindingsToDescendants(n,b),{controlsDescendantBindings:!0}},binders:{ignoreHidden:{createOptions:"ignoreHidden"},gridSize:{createOptions:"gridSize",bindings:{name:"gridSize",vmToObj:{setter:"setGridSize"}}},maxZoom:{createOptions:"maxZoom",bindings:{name:"maxZoom",vmToObj:{setter:"setMaxZoom"}}},styles:{createOptions:"styles",bindings:{name:"styles",vmToObj:{setter:function(a,b){a.setStyles(b),a.resetViewport(),a.redraw()}}}},calculator:{createOptions:"calculator"}}},a.virtualElements.allowedBindings.clusterer=!0,a.bindingHandlers.marker.binders.clusterer={bind:function(e,f,g,h){var i=a.utils.unwrapObservable(f.clusterer)||d,j=e[i];j&&(b(g,j),h.add(function(){c(g)})),a.isObservable(f.clusterer)&&h.addKOSubscription(f.clusterer.subscribe(function(a){a&&b(g,e[a])}))}}}()});